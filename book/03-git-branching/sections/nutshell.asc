[[_git_branches_overview]]
=== برنچ‌ها در یک کلمه

برای اینکه به راستی نحوهٔ شاخه‌سازی گیت را درک کنید، باید یک قدم به عقب برگردیم و نحوهٔ ثبت اطلاعات گیت را مطالعه کنیم.

همانطور که از <<ch01-getting-started#ch01-getting-started>> به یاد دارید،‌گیت داده‌ها را به عنوان دسته‌ای از تغییرات یا تفاوت‌هایی بین فایل‌ها ذخیره نمی‌کند؛
بلکه اطلاعات را بر به عنوان مجموعه‌ای از _اسنپ‌شات‌ها_ ذخیره می‌کند.

وقتی یک کامیت می‌سازید، گیت یک آبجکت کامیت که شامل یک نشانگر به اسنپ‌شات دربرگیرندهٔ اطلاعات صحنهٔ شماست را ذخیره می‌کند.
این آبجکت همچنین شامل نام نویسنده و آدرس ایمیل او، پیغامی که وارد کرده‌اید و یک نشانگر به کامیت یا کامیت‌هایی که مستقیماً قبل این کامیت (والد یا والدین) آمده‌اند است.
کامیت اولیه والدی ندارد؛ یک کامیت معمولی یک والد دارد؛ یک کامیت که حاصل مرج یک یا چند برنچ است چند والد دارد.

برای ملموس کردن این موضوع، فرض را بر این بگذاریم که پوشه‌ای حاوی سه فایل داریم و شما همهٔ آنها را استیج و کامیت می‌کنید.
استیج کردن فایل‌های برای هر کدام از آنها یک چک‌سام (هش SHA-1 که در<<ch01-getting-started#ch01-getting-started>> ذکر کردیم) محاسبه می‌کند، آن نسخه از فایل را در مخزن گیت ذخیره می‌کند،
(گیت از این فایل‌های با نام _بلاب_ یاد می‌کند) و آن چک‌سام را به استیج اضافه می‌کند:

[source,console]
----
$ git add README test.rb LICENSE
$ git commit -m 'Initial commit'
----

وقتی کامیتی را با اجرای `git commit` می‌سازید، گیت همهٔ زیرپوشه‌ها (در مثال فقط روت پروژه) را چک‌سام می‌کند و آن‌ها را به عنوان یک آبجکت درخت در مخزن گیت ذخیره می‌کند.
سپس گیت یک کامیت آبجکت که متادیتا و نشانگری که به روت درخت پروژه دارد می‌سازد تا بتواند اسنپ‌شات پروژه را هنگامی که نیاز بود بازسازی کند.(((git commands, commit)))

مخزن گیت شما حالا پنج آبجکت دارد: سه _بلاب_ (هر کدام نماینده محتوای یکی از سه فایل هستند)، یک _درخت_ که محتویات پوشه را لیست می‌کند و
تعیین می‌کند که چه فایل نام‌هایی در چه بلاب‌هایی ذخیره شده‌اند و یک _کامیت_ با نشانگری به روت آن درخت و تمام متادیتای خود کامیت.

.یک کامیت و درختش
image::images/commit-and-tree.png[A commit and its tree.]

اگر تغییری ایجاد کنید و دوباره کامیت بگیرید، کامیت بعدی نشانگری را به کامیتی که دقیقاً قبل از آن آمده در خود ذخیره می‌کند.

.کامیت‌ها و والدینشان
image::images/commits-and-parents.png[Commits and their parents.]

یک برنچ گیت یک نشانگر سبک‌وزن قابل انتقال به یکی از این کامیت‌هاست.
نام پیش‌‌فرض برنچ در گیت `master` است.
همچنان که کامیت می‌سازید، یک برنچ `master` برایتان ساخته می‌شود که به آخرین کامیتی که ساخته‌اید اشاره می‌کند.
هر بار که کامیت می‌کنید نشانگر برنچ `master` به طور خودکار به جلو حرکت می‌کند.

[NOTE]
====
برنچ ``master'' در گیت برنچ خاصی نیست.(((master)))
این برنچ دقیقاً مشابه هر برنچ دیگری است.
تنها دلیلی که تقریباً همهٔ مخزن‌ها یک برنچ با این نام دارند این است که دستور `git init` به طور پیش‌فرض آنرا می‌سازد و بیشتر مردم هم زحمت تغییر این نام را به خود نمی‌دهند.
====

.یک برنچ و تاریخچهٔ کامیت‌هایش
image::images/branch-and-history.png[A branch and its commit history.]

[[_create_new_branch]]
==== ساختن یک برنچ جدید

(((branches, creating)))
وقتی یک برنچ جدید می‌سازید چه اتفاقی می‌افتد؟
انجام این کار یک نشانگر جدید برای شما می‌سازد تا آنرا به این سو و آن سو انتقال دهید.
فرض بر این بگذاریم که می‌خواهید برنچ جدیدی با نام `testing` بسازید.
شما این کار را با دستور `git branch` انجام می‌دهید:(((git commands, branch)))

[source,console]
----
$ git branch testing
----

این کار یک نشانگر جدید به کامیتی که روی آن هستید می‌سازد.

.دو برنچ که به یک دسته از کامیت‌ها اشاره می‌کنند
image::images/two-branches.png[Two branches pointing into the same series of commits.]

چگونه گیت می‌داند که روی چه برنچی کار می‌کنید؟
گیت نشانگر خاصی به نام `HEAD` (هد) را در خود دارد.
به خاطر داشته باشید این مفهوم تفاوت زیادی با مفهوم `HEAD` در دیگر VCSها، مانند ساب‌ورژن یا CVS، دارد که ممکن است از پیشتر به یاد داشته باشید.
در گیت، هد نشانگری است که به برنچ محلی که روی آن هستید اشاره می‌کند.
در مثالی که روی آن کار می‌کنیم شما هنوز روی `master` هستید.
دستور `git branch` فقط یک برنچ جدید _ساخت_ -- به برنچ جدید نقل مکان نکرد.

.هد که به یک برنچ اشاره می‌کند
image::images/head-to-master.png[HEAD pointing to a branch.]

به سادگی هر چه تمام شما می‌توانید با اجرای دستور `git log`، که به شما نشان می‌دهد چه برنچی به کجا اشاره دارد، این موضوع را بررسی کنید.
این آپشن `--decorate` خوانده می‌شود.

[source,console]
----
$ git log --oneline --decorate
f30ab (HEAD -> master, testing) Add feature #32 - ability to add new formats to the central interface
34ac2 Fix bug #1328 - stack overflow under certain conditions
98ca9 Initial commit
----

شما می‌توانید برنچ‌های `master` و `testing` را که دقیقاً کنار کامیت `f30ab` هستند ببینید.

[[_switching_branches]]
==== تعویض شاخه‌ها

(((branches, switching)))
برای تعویض یا جابه‌جایی به یک برنچ از پیش ساخته شده دستور `git checkout` را اجرا می‌کنید.(((git commands, checkout)))
حال بیایید به برنچ جدید `testing` برویم:

[source,console]
----
$ git checkout testing
----

این کار `HEAD` را جابه‌جا می‌کند تا به برنچ `testing` اشاره کند.

.هد به برنچ فعلی اشاره می‌کند
image::images/head-to-testing.png[HEAD points to the current branch.]

تأثیر این کار در چه بود؟
خب، بیایید یک کامیت دیگر انجام دهیم:

[source,console]
----
$ vim test.rb
$ git commit -a -m 'made a change'
----

.هنگامی که کامیتی ساخته می‌شود برنچ هد به جلو می‌رود
image::images/advance-testing.png[The HEAD branch moves forward when a commit is made.]

این مسئله جالب است چرا که الآن برنچ `testing` به جلو رفت در حالی که برنچ `master` هنوز به کامیتی که سابقاً، حین اجرای `git checkout` که برای تعویض برنچ‌ها استفاده شد، اشاره می‌کند.
بیایید دوباره به برنچ `master` بازگردیم:

[source,console]
----
$ git checkout master
----

[NOTE]
.`git log` _همیشه_، _همهٔ_ برنچ‌ها را نمایش نمی‌دهد.
====
اگر الآن `git log` را اجرا می‌کردید ممکن بود از اینکه برنچ «testing»ـی که همین الآن ساختید کجا رفت متعجب شوید، چرا که قاعدتاً نباید در خروجی نمایش داده شود.

برنچ مذکور غیب نشده است؛ صرفاً گیت گمان نمی‌کند که شما علاقه‌ای به دانستن اطلاعات آن برنچ دارید و سعی می‌کند مطالبی که به نظرش برای شما مفید است را به شما نشان دهد.
به بیان دیگر، در حالت پیش‌فرض، `git log` فقط تاریخچهٔ کامیت‌های زیر برنچی که شما چک‌اوت کرده‌اید را نمایش می‌دهد.

برای نمایش تاریخچهٔ کامیت‌های برنچ مورد نظر باید به صراحت آن را نام ببرید: `git log testing`.
برای نمایش تمام برنچ‌ها `--all` را به دستور `git log`تان بی‌افزایید.
====

.وقتی چک‌اوت می‌کنید هد جابه‌جا می‌شود
image::images/checkout-master.png[HEAD moves when you checkout.]

آن دستور دو کار اصلی انجام داد.
نشانگر هد را بازگردان تا به برنچ `master` اشاره کند و فایل‌هایی که در پوشه کاری کاری شما بودند را به اسنپ‌شاتی که `master` به آن اشاره می‌کرد بازگردانی (Revert/ریورت) کرد.
این مسئله همچنین به این معنا است که تغییراتی که از این نقطه به بعد اعمال کنید از نسخه‌های قدیمی‌تر پروژه جدا خواهد ماند.
در ساده‌ترین تعریف، کاری که در برنچ `testing` کردید را خنثی می‌کند تا بتوانید راه دیگری را در پیش بگیرید.

[NOTE]
.تعویض برنچ فایل‌های درون پوشه کاری را تغییر می‌دهد
====
بسیار مهم است که به خاطر داشته باشید که تعویض برنچ در گیت فایل‌هایی که در پوشه کاری دارید را تغییر می‌دهد.
اگر به برنچ قدیمی‌تری انتقال پیدا کنید، پوشه کاری شما به آن صورتی بازگردانی خواهد شد که آخرین بار هنگام ایجاد کامیت بود روی آن برنچ بوده است.
اگر گیت نتواند این بازگردانی را به صورت بی‌نقص انجام دهد، نمی‌گذارد که تعویض برنچ انجام شود.
====

بیایید چند تغییر جدید اعمال کنیم و دوباره کامیت بگیریم:

[source,console]
----
$ vim test.rb
$ git commit -a -m 'made other changes'
----

اکنون تاریخچه پروژه شما دوشاخه شده است (به <<divergent_history>> مراجعه کنید).
شما یک برنچ ساختید و به آن انتقال پیدا کردید، کمی روی آن کار کردید و سپس به برنچ اصلیتان بازگشتید و کمی کار متفاوت آنجا انجام دادید.
هر دوی آن تغییرات به صورت ایزوله در برنچ‌های خودشان موجوداند: شما می‌توانید بین برنچ‌ها جابه‌جا شوید و هرگاه آماده بودید آنها را با هم مرج کنید.
و جالبتر اینکه همهٔ این کارها صرفاً با دستورهای `branch`، `checkout` و `commit` انجام دادید.

[[divergent_history]]
.تاریخچه دوشاخه شده
image::images/advance-master.png[Divergent history.]

علاوه بر آن، با دستور `git log` می‌توانید این اطلاعات را ببینید.
اگر `git log --oneline --decorate --graph --all` را اجرا کنید، برنامه تاریخچهٔ کامیت‌های شما را نمایش می‌دهد، نشان می‌دهد که نشانگرهای برنچ‌هایتان کجاست و چگوننه تاریخچهٔ شما دو شاخه شده است.

[source,console]
----
$ git log --oneline --decorate --graph --all
* c2b9e (HEAD, master) Made other changes
| * 87ab2 (testing) Made a change
|/
* f30ab Add feature #32 - ability to add new formats to the central interface
* 34ac2 Fix bug #1328 - stack overflow under certain conditions
* 98ca9 initial commit of my project
----

از این جهت که برنچ در گیت صرفاً یک فایل سادهٔ محتوی یک چک‌سام SHA-1 چهل حرفی کامیتی است که به آن اشاره می‌کند، ساختن و از بین بردن برنچ‌ها کم هزینه است.
ساختن یک برنچ جدید به سادگی و سرعت نوشتن ۴۱ بایت اطلاعات درون یک فایل است (۴۰ حرف و یک خط جدید).

این قضیه بسیار متفاوت با نحوهٔ برنچ‌سازی ابزارهای VCS قدیمی است که شامل کپی کردن تمام فایل‌های پروژه به یک پوشه ثانوی می‌باشد.
این می‌تواند چندین ثانیه یا حتی دقیقه، بسته به سایز پروژه، طول بکشد؛ درحالی که در گیت این فرآیند همیشه آنی است.
همچنین به علت اینکه هنگامی که کامیت می‌کنیم والد را هم در کامیت ثبت می‌کنیم، پیدا کردن یک پایهٔ ادغام برای مرج کردن به صورت خودکار برای ما انجام می‌شود و به طور کل به سهولت انجام می‌پذیرد.
معمولاً مزایا توسعه‌دهندگان را به ساختن و استفاده از برنچ‌ها مشتاق می‌کند.

بیایید به اینکه چرا باید شما هم از این کار را کنید نگاهی بیاندازیم.

[NOTE]
.ساختن یک برنچ جدید و انتقال به آن در آن واحد
====
خیلی اوقات پیش می‌آید که یک برنچ جدید بسازید و در آن واحد بخواهید به آن انتقال یابید -- این کار در یک عملیات با `git checkout -b <newbranchname>` قابل انجام است.
====
