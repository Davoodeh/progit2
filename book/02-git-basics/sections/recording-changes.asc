=== ثبت تغییرات یک مخزن
در این بخش، شما باید یک مخزن واقعی گیت بر روی سیستم محلی داشته باشید و یک چک‌اوت یا _‌کپی کاری‌_  تمام فایل‌های موجود مقابل شما باشد.
معمولاً، شما می‌خواهید شروع به اعمال تغییرات و هنگام رسیدن پروژه به درجهٔ خاصی، کامیت اسنپ‌شات‌های همان کامیت‌ها در مخزن کنید.

بخاطر داشته باشید که هر فایل در پوشه کاری شما می‌تواند یکی از این دو حالت را داشته باشد:
_Tracked (رهگیری شده)_ یا _Untracked (دنبال نشده/آن‌ترکت)_.
فایل‌های رهگیری شده فایل‌هایی هستند که در آخرین اسنپ‌شات شما بوده‌اند؛ آن‌ها می‌توانند ویرایش‌نشده،
ویرایش‌شده یا استیج‌شده داشته باشند.
به طور خلاصه، فایل‌های رهگیری شده آنهایی هستند که گیت آن‌ها را می‌شناسد.

فایل‌های رهگیری نشده مابقی فایل‌ها هستند -- هر فایلی در اسنپ‌شات آخر شما نبوده باشد و شما آن را _add_ نکرده باشید.
هنگامی که اولین‌بار مخزنی را کلون می‌کنید، همه‌ی فایل‌ها رهگیری‌شده و دست نخورده هستند زیرا گیت همین الآن آنها را چک‌اوت کرده است و چیزی ویرایش نشده است.

به محض تغییر فایل‌ها، گیت وضعیت‌ آن‌ها را به ویرایش‌شده تغییر می‌دهد، چون شما آن را نسبت به کامیت آخر تغییر داده‌اید.
همانطور که کار می‌کنید، به طور انتخابی این فایل‌ها را استیج کرده و تغییرات اعمال شدهٔ تحت استیج را کامیت می‌کنید و این چرخه تکرار می‌شود.


.چرخه عمر وضعیت فایل‌های شما.
image::images/lifecycle.png[The lifecycle of the status of your files.]

[[_checking_status]]
==== بررسی وضعیت فایل‌ها

ابزار اصلی که شما برای تعیین وضعیت فایل‌ها استفاده می‌کنید، دستور `git status` است. (((git commands, status)))
اگر شما دستور را مستقیماً بعد از کلون اجرا کنید،‌ باید چیزی شبیه به این ببینید:

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working directory clean
----

این بدین معنی است که پوشه کاری شما تمیز است؛ به زبان دیگر، هیچ کدام از فایل‌های رهگیری‌شده شما ویرایش نشده‌اند.
علاوه بر این گیت هیچ فایل دنبال نشده‌ای نمی‌بینید.
در آخر، این دستور به شما می‌گوید که بر روی کدام شاخه و شعبه هستید و به شما اطلاع می‌دهد که شاخه مذکور از همان شاخه‌ای که روی سرور است نیامده است.
فعلاً، آن شاخه همیشه `master` است که به صورت پیش فرض ساخته شده است؛ نگران نباشید در بخش <<_git_branching>> درباره این موضوع
با جزئیات بحث خواهد شد.

فرض کنیم یک فایل جدید به پروژه اضافه می‌کنیم، یک فایل `README` ساده.
اگر فایل از قبل وجود نداشت و `git status` را اجرا می‌کردید، فایل‌‌های رهگیری نشده را به شکل زیر می‌دیدید:


[source,console]
----
$ echo 'My Project' > README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Untracked files:
  (use "git add <file>..." to include in what will be committed)

    README

nothing added to commit but untracked files present (use "git add" to track)
----

همانطور که می‌بینید فایل `README` جدیدتان در حالت رهگیری‌نشده است، چون وضعیت فایل در زیر تیتر «Untracked files» خروجی است.
به طوری کلی رهگیری‌نشده به این معنی است که گیت فایلی یافته است که در اسنپ‌شات (کامیت) قبلی نداشته‌اید؛
گیت آن را به اسنپ‌شات‌های (کامیت‌های) بعدی اضافه نمی‌کند تا زمانی که شما صراحتاً به گیت بگویید که این کار را کند.
گیت این کار را می‌کند تا شما‌ به صورت اتفاقی شروع به اضافه کردن فایل‌های اجرایی یا دیگر فایل‌هایی که نمی‌خواهید به مخزن اضافه شوند نکنید.
شما می‌خواهید شروع به اضافه کردن فایل `README` کنید، پس بیایید رهگیری آن را شروع کنیم.

[[_tracking_files]]‍
==== دنبال کردن فایل‌های جدید

به این ترتیب برای قرار دادن یک فایل در حالت tracked از دستور `git add` استفاده می‌کنید.(((git commands, add)))
برای شروع پیگیری فایل `README` می‌توانید این دستور را اجرا کنید:

[source,console]
----
$ git add README
----

اگر دستور `git status` را دوباره وارد کنید، می‌توانید ببیند حالا فایل `README` در حالت رهگیری‌شده و استیج‌شده قرار دارد تا کامیت شود:

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)

    new file:   README

----

می‌توانید بگویید که فایل تحت استیج است چراکه فایل در زیر تیتر «Changes to be committed» قرار دارد.
اگر در این نقطه کامیتی بگیرید، نسخه‌ای از فایل در اسنپ‌شات متعاقب خواهد بود که در زمان اجرای `git add` وجود داشته است.
ممکن است پیشتر، زمانی را به خاطر داشته باشیدکه دستور `git init` و پس از آن `git add <files>` را اجرا کردید --
تا شروع به رهگیری فایل‌هایی که در مخزنتان است کرده باشید.(((git commands, init)))(((git commands, add)))
دستور `git add` مسیری را برای یک فایل یا پوشه می‌گیرد؛ اگر یک پوشه باشد، دستور به صورت بازگشتی تمامی فایل‌های آن پوشه را اضافه می‌کند.

==== استیج‌کردن فایل‌های ویرایش‌شده

بیایید فایلی که در حال حاضر رهگیری‌شده است را تغییر دهیم.
اگر یک فایل از قبل رهگیری‌شده به نام `CONTRIBUTING.md` تغییر دهید و دوباره دستور `git status` را اجرا کنید،
چیزی شبیه به نتیجه زیر را می‌بینید:

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md

----

فایل `CONTROBUTING.md` در بخشی به نام «Changes not staged for commit» ظاهر خواهد شد -- به معنی که فایلی در پوشه کاری ویرایش شده است که هنوز آنرا استیج نکرده‌ایم.
برای استیج کردن آن می‌بایست دستور `git add` را اجرا کنید.
دستور `git add` چند منظوره است -- از آن برای رهگیری کردن فایل‌های جدید، استیج کردن و برای انجام دیگر کارها
مثل علامت زدن تداخلات فایل‌ها به عنوان حل شده استفاده می‌کنید.
ممکن است نگاه به آن به عنوان «این محتوا را به کامیت بعدی اضافه کن» قابل فهم‌تر باشد تا «این فایل را به پروژه اضافه کن».
بیایید دستور `git add` را اجرا کنیم تا فایل `CONTRIBUTING.md` را استیج کنیم، و بعد دستور `git status` را دوباره وارد کنیم:

[source,console]
----
$ git add CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md

----

هر دو فایل استیج شده‌اند و به کامیت بعدی شما اضافه خواهند شد.
در این لحظه، فرض کنید که یادتان می‌یاد یک تغییر کوچک دیگر در فایل `CONTRIBUTING.md` می‌خواهید انجام دهید، قبل از اینکه کامیت کنید.
فایل را دوباهر باز می‌کنید و تغییرات را اعمال می‌کنید، حالا اماده کامیت است.
حالا، بیایید دوباره دستور `git status` را اجرا کنیم:

[source,console]
----
$ vim CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md

----

چطور ممکنه؟!!!
فایل `CONTRIBUTING.md` هم به عنوان فایلی استیج‌شده و _همچنین‌_ استیج‌نشده لیست شده است.
چطور امکان دارد؟
مشخص می‌شود که گیت فایل را دقیقاً به آن صورتی استیج می‌کند که هنگام اجرای دستور `git add` بوده است.
اگر الآن کامیت کنید، نسخهٔ `CONTRIBUTING.md` آنی خواهد بود که آخرین بار `git add` را روی آن اجرا کرده‌اید و همانگونه به کامیت اضافه می‌شود،
آن نسخه‌ای که هنگام اجرای `git commit` در پوشهٔ کاری شماست ذخیره نمی‌شود.
اگر فایلی را بعد از اجرای `git add` ویرایش کنید، باید `git add` را دوباره اجرا کنید تا آخرین نسخهٔ فایل را دوباره استیج کنید:

[source,console]
----
$ git add CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md
----

==== وضعیت‌های کوتاه

خروجی `git status` خیلی توصیفی و لغوی است؛
گیت همچنین فلگی برای اعلام وضعیت‌های کوتاه دارد که شما را قادر می‌کند تغییرات خود را به طور خلاصه‌تر ببینید.
اگر دستور `git status -s` یا `git status --short` را وارد کنید، یک خروجی ساده شده خواهید گرفت:

[source,console]
----
$ git status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt
----

فایل‌های جدیدی که هنوز رهگیری نشده‌اند علامت `??` مقابل آنان است، فایل‌های جدیدی که استیج شده‌اند علامت `A` دارند،
فایل‌های ویرایش‌شده علامت `M` دارند و بقیه نیز به همین ترتیب.
خروجی شامل دو ستون است -- ستون سمت چپ نشان‌دهنده وضعیت استیج است و ستون سمت راست نشان‌دهنده وضعیت درخت کاری است.
برای مثال در خروجی بالا، فایل `README` در پوشه کاری تغییر یافته است اما هنوز استیج نشده،
در حالی که فایل `lib/simplegit.rb` ویرایش و استیج شده است.
فایل `Rakefile` ویرایش و استیج شده بود و بعد دوباره به ویرایش شده، به همین دلیل تغییرات آن هم استیج شده و استیج نشده هستند.

[[_ignoring]]
==== نادیده گرفتن فایل‌ها

اغلب مجموعه‌ای از فایل‌ها خواهید داشت که نمی‌خواهید گیت به طور خودکار آنها را اضافه یا حتی به عنوان رهگیری نشده به شما نشان دهد.
به صورت کلی این فایل‌ها، فایل‌هایی که به صورت خودکار ساخته می‌شوند مثل سیاهه‌ها و فایل‌هایی که توسط سیستم ساخته می‌شوند.
در این گونه موارد، شما می‌توانید فایلی داشته باشید که همهٔ آنها را با الگوهایی مرتبط لیست می‌کند و آنرا `.gitignore` بنامید.(((ignoring files)))
در اینجا مثالی برای فایل `gitignore.` داریم:

[source,console]
----
$ cat .gitignore
*.[oa]
*~
----

خط اول به گیت می‌گوید که هر فایلی که با «.o» یا «.a» تمام ‌می‌شود را نادیده بگیرد -- فایل‌های آرشیو یا آبجکت‌هایی که ممکن است حاصل خروجی کد شما باشند.
خط دوم به گیت می‌گوید که همه‌ی فایل‌های که نام‌شان با علامت مد (`~`) پایان‌یافته است را نادیده بگیرد، علامتی که توسط کثیری از ویرایشگرها مانند
ایمکس استفاده می‌شود تا فایل‌های موقت خود را علامت‌گذاری کنند.
شاید حتی یک پوشهٔ log، tmp و یا pid، فایل مستنداتی که خودکار ساخته شده‌اند و سایر را هم اضافه کنید.
راه‌اندازی یک فایل `.gitignore` برای مخزن جدیدتان پیش از اینکه کار خود را شروع کنید تمرین خوبی است چرا که نمی‌خواهید به طور اتفاقی فایل‌هایی را کامیت کنید که قصد ذخیره آنها را در مخزن گیت خود نداشته‌اید.

قوانین الگو‌هایی که می‌توانید در فایل `gitignore.` قرار دهید به این صورت است:

*  خط‌های خالی یا خط‌هایی که با `#` شروع شوند نادیده گرفته می‌شوند.
*  الگو‌‌های استاندارد گلاب کار می‌کنند و به صورت بازگشتی بر روی درخت کاری شما اعمال می‌شوند.
*  می‌توانید الگوها را با یک اسلش رو به جلو (`/`) شروع کنید تا از حالت بازگشتی آن اجتناب کنید.
*  می‌توانید الگو‌ها را با یک اسلش رو به جول (`/`) تمام کنید تا پوشه‌ای را مشخص کنید.
*  می‌توانید الگویی را با اضافه کردن علامت تعجب (`!`) برعکس کنید.

الگو‌های گلاب مانند عبارات منظم ساده شده‌ای هستند که شل‌ها از آن استفاده می‌کنند.
یک ستاره (`*`) با یک یا چند حرف تطبیق داده می‌شود؛ `[abc]` هر حرفی که داخل براکت یا قلاب باشد را تطبیق می‌دهد (در این مثال a، b، یا c هستند)؛
یک علامت سوال (`?`) یک تک حرف را تطبیق می‌دهد؛ و براکت‌هایی که حروفی را که با خط تیره از هم جدا شده باشند (`[9-0]`) را محاصره کرده باشند هر حرفی که
در آن مجموعه وجود داشته باشند را پیدا می‌کند (در این مورد هر عددی که بین 0 تا 9 باشد).
همچنین می‌توانید از دو ستاره برای تطبیق پوشه‌های تو در تو استفاده کنید؛ `a/**/z` با `a/z`، `a/b/z`، `a/b/c/z` و ساختارهای مشابه تطبیق پیدا می‌کرد.

در اینجا مثال دیگری برای فایل `gitignore.` داریم:

[source]
----
# ignore all .a files
*.a

# but do track lib.a, even though you're ignoring .a files above
!lib.a

# only ignore the TODO file in the current directory, not subdir/TODO
/TODO

# ignore all files in any directory named build
build/

# ignore doc/notes.txt, but not doc/server/arch.txt
doc/*.txt

# ignore all .pdf files in the doc/ directory and any of its subdirectories
doc/**/*.pdf
----

[TIP]
====
گیت‌هاب لیست قابل فهم خوبی از نمونه فایل‌های `.gitignore` مملوع از مثال‌های مختلف برای زبان‌ها و پروژه‌های مختلف در https://github.com/github/gitignore[] دارد، اگر دنبال یک نمونه آغازین برای پروژه خود هستید.
====

[NOTE]
====

در این مثال‌های ساده، یک مخزن شاید یک فایل `.gitignore` در پوشه روت خود داشته باشد، که به صورت بازگشتی روی تمام پروژه اعمال می‌شود.
با این حال، این امکان هم وجود دارد که پروژه‌‌ها در زیر پوشه‌های خود باز هم فایل `gitignore.` داشته باشد.
قوانین درون این فایل‌های `gitignore.` تو در تو فقط روی فایل‌های زیر پوشه‌های آنها اعمال می‌شود
(مخزن منبع هسته لینوکس ۲۰۶ فایل `gitignore.` دارد.)

این موضوع و جزئیات فایل‌های `.gitignore` چندگانه خارج از بحث کتاب است؛ برای جزئیات بیشتر به `man gitignore` مراجعه کنید.
====

[[_git_diff_staged]]
==== نمایش تغییرات استیج‌شده و استیج‌نشده

اگر دستور `git status` کمی برایتان مبهم است -- میخواهید بفهمید دقیقاً چه چیزی نه فقط چه فایل‌هایی را تغییر داده‌اید --
می‌توانید از دستور `git diff` استفاده کنید.(((git commands, diff)))
درباره دستور `git diff` و جزئیات آن بعد می‌گوییم، اما احتمالاً شما از این دستور بیشتر برای پاسخ به دو سؤال استفاده کنید: چه چیزی را تغییر داده‌اید اما هنوز استیج نکرده‌اید؟
و چه چیزی را استیج کرده و در شرف کامیت کردن آن هستید؟
با اینکه دستور `git status` جواب آن سؤالات را به صورت کلی، به واسطه لیست کردن نام‌های فایل‌ها خواهد داد، اما `git diff`
جزئیات دقیق خطوط اضافه و حذف شده -- انگار پچ آنرا -- به شما نشان می‌دهد.

فرض کنیم که شما از دوباره فایل `README` را تغییر داده‌اید و استیج کرده‌اید و سپس فایل `CONTRIBUTING.md` را بدون استیج کردن ویرایش کرده‌اید.
اگر دستور ‍`git status` را اجرا کنید، دگر بار چیزی شبیه به خروجی پایین می‌بینید:

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    modified:   README

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
----

برای دیدن تغییراتی که انجام دادید ولی هنوز استیج نکرده‌اید، دستور `git diff` را بدون هیچ آرگومان دیگری وارد کنید:

[source,console]
----
$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if your patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's
----

آن دستور چیز‌هایی که در پوشه کاری شما هست را با محتویات استیج مقایسه می‌کند.
نتیجه‌ به تغییراتی را به شما نشان می‌دهد که اعمال کرده‌اید اما هنوز استیج نکرده‌اید.

اگر می‌خواهید ببینید چه چیزی را استیج کرده‌اید که در کامیت بعدی شما باشد، می‌توانید از `git diff --staged` استفاده کنید.
این دستور آخرین کامیت را با تغییرات استیج مقایسه می‌کند:

[source,console]
----
$ git diff --staged
diff --git a/README b/README
new file mode 100644
index 0000000..03902a1
--- /dev/null
+++ b/README
@@ -0,0 +1 @@
+My Project
----

خیلی مهم است که دقت کنید که `git diff` خودش به تنهایی تمام تغییرات ایجاد شده از آخرین کامیت را نشان نمی‌دهد -- بلکه فقط تغییراتی که هنوز استیج نشده‌اند را به نمایش می‌گذارد.
اگر شما تغییراتی را به استیج کنید، `git diff` خروجی‌ای به شما نمی‌دهد.

برای مثالی دیگر، اگر شما فایل `CONTRIBUTING.md` را استیج کنید و سپس آن را تغییر دهید، می‌توانید از دستور `git diff` استفاده کنید
و تغییرات ایجاد شده درون فایل که استیج شده‌اند و تغییراتی که استیج نشده‌اند.
اگر محیط ما شبیه پایین باشد:

[source,console]
----
$ git add CONTRIBUTING.md
$ echo '# test line' >> CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
----

حال می‌توانید از `git diff` برای دیدن مواردی که هنوز استیج نشده‌اند استفاده کنید:

[source,console]
----
$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 643e24f..87f08c8 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -119,3 +119,4 @@ at the
 ## Starter Projects

 See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).
+# test line
----

و `git diff --cached` برای اینکه ببینید چه چیزی را تا اینجای کار استیج کرده‌اید (`staged--` و `cached--` مترادف هستند):

[source,console]
----
$ git diff --cached
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if your patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's
----

[NOTE]
دستور `git diff` یک ابزار خارجی است.
====
در ادامهٔ کتاب از دستور `git diff` به طرق مختلفی استفاده خواهیم کرد.
اگر ابزارهای گرافیکی یا برنامه‌های نمایش دیف دیگری را ترجیح می‌دهید راه دیگری هم برای مشاهده این دیف هست.
اگر `git difftool` را به جای `git diff` اجرا کنید، می‌تواند هر کدام از این دیف‌ها را در نرم‌افزارهایی مثل emerge، vimdiff و غیره (شامل نرم‌افزارهای تجاری) ببینید.
دستور `git difftool --tool-help` را اجرا کنید تا ببنید که چه نرم‌افزارهایی بر روی سیستم شما موجود است.
====

[[_committing_changes]]
==== کامیت کردن تغییراتتان

اکنون استیج شما آنطور که می‌خواستید آماده شده است، می‌توانید تغییرات خود را کامیت کنید.
به یاد داشته باشید که هر چیزی که همچنان استیج‌نشده است -- هر فایلی که ساخته‌اید یا تغییر داده‌اید که هنوز دستور
`git add` برای استیج کردن آن‌ها اجرا نکرده‌اید -- به کامیت اضافه نخواهند شد.
آن‌‌ها با عنوان فایل تغییر یافته بر روی دیسک شما باقی خواهد ماند.
در این مورد، فرض کنیم که آخرین باری که دستور `git status` اجرا کردید، مشاهده کرده‌اید که تمام تغییرات استیج شده‌اند،
پس آماده‌اید که تغییرات استیج شده را کامیت کنید.(((git commands, status)))
راحت‌ترین راهی که می‌توانید کامیت را انجام دهید نوشتن دستور `git commit` است:(((git commands, commit)))

[source,console]
----
$ git commit
----

انجام این کار ویرایشگرتان را باز می‌کند.

[NOTE]
====
ویرایشگر با متغیر محیطی `EDITOR` شل شما تنظیم می‌شود --
معمولاً ویم یا ایمکس است، هرچند همانطور که در <<ch01-getting-started#ch01-getting-started>>
می‌توانید آنرا با استفاده از دستور `git config --global core.editor` با هر چیزی که می‌خواهید جایگزین کنید.(((editor, changing default)))(((git commands, config)))
====

ویرایشگر متن زیر را به نمایش می‌گذارد (این مثال یک صفحه ویم است):

[source]
----

# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Your branch is up-to-date with 'origin/master'.
#
# Changes to be committed:
#	new file:   README
#	modified:   CONTRIBUTING.md
#
~
~
~
".git/COMMIT_EDITMSG" 9L, 283C
----

می‌توانید ببینید که پیام کامیت پیش فرض شامل آخرین خروجی دستور `git status` به صورت کامنت شده و یک خط خالی در بالای آن است.
شما می‌توانید تمام این کامنت‌ها را حذف کرده و پیام خود را بنویسید، یا می‌توانید همانطور آنها رها کنید تا به شما یادآوری کنند که در حال کامیت کردن چه چیزی هستید.

[NOTE]
====
برای یادآوری صریح‌تر از مواردی که ویرایش کرده‌اید، آپشن `-v` را به `git commit` بدهید.
همچنین انجام این کار دیف تغییراتتان را در ویرایشگر قرار می‌دهد تا بتوانید ببینید دقیقاً چه تغییراتی را کامیت می‌کنید.
====

وقتی از ادیتور خارج می‌شوید، گیت کامیت مورد نظر شما را با پیام کامیتی که نوشته‌اید (بدون کامنت‌ها و دیف‌ها) می‌سازد.
به عنوان یک روش دیگر، می‌توانید پیام کامیت خود را به صورت درون خطی همراه با دستور `git commit` با آپشن `m-` بنویسید،‌ مانند مثال زیر:

[source,console]
----
$ git commit -m "Story 182: fix benchmarks for speed"
[master 463dc4f] Story 182: fix benchmarks for speed
 2 files changed, 2 insertions(+)
 create mode 100644 README
----

حال شما اولین کامیت خود را ساختید!
می‌توانید ببینید که کامیت، چند خروجی درباره خودش به شما می‌دهد: بر روی کدام برنچ کامیت انجام شده است (`master`)،
کد هش SHA-1 خودش (`463dc4f`)، چه فایل‌هایی تغییر کرده‌اند و آمارهایی در کامیت جاری، درباره خط‌هایی که اضافه یا حذف شده‌اند.

به یاد داشته باشید که کامیت، اسنپ‌شاتی را ثبت می‌کند که شما در موقعیت استیج آماده‌سازی کرده‌اید.
هر چیزی که شما استیج نکرده‌اید همچنان با عنوان فایل تغییر یافته باقی مانده‌ است؛ شما می‌توانید کامیت دیگری بسازید
و آن را به تاریخچه‌ی تغییرات خود اضافه کنید.
هر زمانی که یک کامیت جدید ایفا می‌کنید، شما اسنپ‌شاتی از پروژه خود می‌سازید که در هر زمان می‌توانید پروژه
را به همان اسنپ‌شات برگردانید یا مقایسه کنید.

==== رد کردن موقعیت استیج

(((staging area, skipping)))
موقعیت استیج گاهی اوقات شاید آنطور که ما باید انتظار داریم پیش نمی‌رود و بیش از حد شلوغ می‌شود.
اگر می‌خواهید از مرحله استیج کردن فایل‌ها رد شوید و سریع وارد مرحله کامیت شوید، گیت یک شورت‌کات ساده برای شما آماده کرده است.
با اضافه کردن آپشن `a-` به دستور `git commit` باعث می‌شود گیت به صورت اتوماتیک هر فایلی که ترک شده را استیج کند و آماده کامیت کند،
به طور کلی به این آپشن مرحله `git add` را انجام می‌دهد:

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md

no changes added to commit (use "git add" and/or "git commit -a")
$ git commit -a -m 'Add new benchmarks'
[master 83e38c7] Add new benchmarks
 1 file changed, 5 insertions(+), 0 deletions(-)
----

دقت کنید که چرا نباید دستور `git add` برای فایل `CONTRIBUTING.md` در این مورد اجرا کنید قبل از اینکه کامیت کنید.
به این دلیل است که آپشن `a-` تمام فایل‌‌هایی است که تغییر کرده‌اند.
این گزینه‌ی راحتی است اما مراقب باشید؛ بعضی وقت‌‌ها باعث می‌شود که شما تغییراتی که نمی‌خواهید را شامل کنید.

[[_removing_files]]
==== حذف‌ کردن فایل

(((files, removing)))

برای حذف یک فایل از گیت،‌ باید آن را از حالت ترکت حذف کنید(درست‌تر بگوییم، آن را از موقعیت استیج حذف کنید) و بعد کامیت کنید.
دستور `git rm` این کار را می‌کند و همچنین فایل را از پوشه کاریتان حذف می‌کند پس شما آن را به عنوان یک فایل آن‌ترکت شده
نخواهید دید.

اگر به سادگی فایل را از پوشه کاریتان حذف کنید،‌ نام فایل را زیر تیتر ``Changed but not updated`` می‌بینید
و در خروجی `git status` شما به (آن وضعیت _unstaged_) می‌گوید.

[source,console]
----
$ rm PROJECTS.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        deleted:    PROJECTS.md

no changes added to commit (use "git add" and/or "git commit -a")
----

سپس، اگر دستور `git rm` را اجرا کنید، گیت فایل را با عنوان فایل حذف شده آن را استیج می‌کند:

[source,console]
----
$ git rm PROJECTS.md
rm 'PROJECTS.md'
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    deleted:    PROJECTS.md
----

دفعه بعد که کامیت کنید، فایل از بین خواهد رفت و دیگر وجود نخواهد داشت.
اگر شما فایل را تغییر دهید و آن را استیج کنید، ـ‌بایدـ از آپشن `f-` استفاده کنید و یه جورایی باید آن را به زور حذف کرد.
این یک امکان امن برای حذف تصادفی اطلاعاتی است که هنوز در هیچ اسنپ‌شاتی ثبتت نشده‌اند و نمی‌توانند نمی‌توانند توسط گیت ثبت شوند.

امکان مفید دیگری شاید بخواهید انجام دهید برای نگه‌داشتن فایل در پوشه کاریتان، اما آن را از محیط استیج حذف کرده‌اید.
در زبانی دیگر، شاید بخوایید آن را در حافظه سخت خود نگه‌دارید ولی نمی‌‌خواهید گیت آن را به هیچ عنوان دنبال کند.
این یک دستور به شدت به درد بخور است چرا اگه فراموش کرده‌اید چیزی را به `gitignore.` اضافه کنید و تصادفا آن را استیج کرده‌اید،
مانند یک فایل لاگ بزرگ یا کلی فایل ‍`a.` کامپایل شده.
به راحتی از آپشن `cached--` استفاده کنید:

[source,console]
----
$ git rm --cached README
----

شما می‌توانید از الگو‌های پوشه‌ها، فایل‌ها و فایل‌های اصلی در دستور `git rm` استفاده کنید.
که به این معنی است شمامی‌توانید اینگونه عمل کنید:

[source,console]
----
$ git rm log/\*.log
----

به بک‌اسلش(‍`\`) در مقابل `*` دقت کنید.
این کار لازم است چون گیت این کار را به علاوه فایل‌های توسعه خودش بر روی  فایل‌های توسعه شما هم اعمال می‌کند.
این دستور تمام فایل‌های توسعه که با پسوند `log.` هستند درون پوشته `/log` را حذف می‌کند.
یا شما می‌توانید چیزی شبیه به دستور زیر را اجرا کنید:

[source,console]
----
$ git rm \*~
----

این دستور تمام فایل‌هایی که نام آن‌ها با یک `~` تمام می‌شود را حذف می‌کند.

[[_git_mv]]
==== جابه‌جایی فایل‌ها

(((files, moving)))
برعکس خیلی از کنترل نسخه‌های دیگر، گیت به صراحت جابه‌جایی‌ها را دنبال نمی‌کند.
اگر شما فایلی را در گیت تغییر نام‌ دهید، هیچگونه متادیتا‌ای در گیت ذخیر نمی‌شود که بعدا بگوید شما آن را تغییر نام داده‌اید.
با این حال، گیت خیلی باهوش است و به راحتی بعد از این کارا می‌فهمد. -- جلوتر درباره جابه‌جایی فایل‌ها حرف خواهیم زد.

بنابراین شاید یکم گیج کننده باشد که گیت دستوری به نام `mv` دارد.
اگر بخواهید نام یک فایل را در گیت تغییر دهید، می‌توانید دستوری شبیه به زیر را اجرا کنید:

[source,console]
----
$ git mv file_from file_to
----

و به خوبی کار کرد.
در حقیقت، اگر شما چیزی شبیه دستور زیر را اجرا کنید و وضعیت را بررسی کنید، می‌بینید که گیت آن را به عنوان فایل تغییر نام یافته
در نظر می‌گیرد:

[source,console]
----
$ git mv README.md README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    renamed:    README.md -> README
----

با این حال، این معادل اجرا کردن دستوری شبیه زیر است:

[source,console]
----
$ mv README.md README
$ git rm README.md
$ git add README
----

گیت فهمید که یک تغییر نام ضمنی است، پس اصلامهم نیست که شما فایلی را با دستور `mv` تغییر نام دهید.
تنها تفاوت اصلی این است که `git mv` یک دستور است به جای سه دستور -- صرفا یک تابع برای آسودگی کار است.
مهم‌تر از هر چیزی این است که شما می‌توانید از هر ابزاری برای تغییر نام یک فایل استفاده کنید.
