[[_undoing]]
=== برگشت کارها

در هر مرحله، شاید بخواهید که چیزی را یا کاری را برگشت دهید. 
اینجا ما برخی ابزار پایه ای برای برگشت تغییرات و کارهایی که انجام دادید را بررسی خواهید کرد.
توجه کنید، شما همین این برگشتها را نمی توانید دوباره برگشت کنید.
اینجا یکی از معدود جاهایی است که اگر حواستان جمع نباشد امکان دارد داده ای از دست برود.

یکی از متداول‌ترین بازگشت‌ها زمانی است که شما کامیتی خیلی زود انجام دادید و احتمالا اضافه کردن چند فایل‌ را فراموش کردید یا
در پیام کامیتتان خطایی رخ داده باشد.
اگر شما بخواهید کامیت را «ریدو» کنید، تغییرات اضافه فراموش شده را اعمال کنید، آنان را استیج کنید و دوباره با استفاده از آپشن
`amend--` دوباره کامیت کنید:

[source,console]
----
$ git commit --amend
----

این دستور منطقه استیج شما را دریافت می‌کند و از آن برای کامیت استفاده می‌کند.
اگر از اخرین کامیتتان هیچ تغییری ایجاد نکرده باشید (برای مثال، شما دستور را به محض انجام کامیت قبلی اجرا می‌کنید)، سپس اسنپ‌شات شما
دقیقا به یک شکل است و تمام چیزی که تغییر می‌کند فقط پیام کامیت شما است و نه چیز دیگری.

همان ویرایشگر پیام کامیت بالا می‌آید، اما در حال حاضر شما پیام کامیت قبلی است.
شما می‌توانید پیام را مانند همیشه اصلاح کنید، اما این عمل بر روی کامیت قبلی بازنویسی می‌شود.

برای مثال، اگر شما کامیت کنید و سپس متوجه شوید که چیزی را فراموش کردید و می‌خواستید آن را استیج کنید و به همین کامیت اضافه کنید،
شما می‌توانید چنین کاری را انجام دهید:

[source,console]
----
$ git commit -m 'Initial commit'
$ git add forgotten_file
$ git commit --amend
----

در نهایت کار شما با یک کامیت به پایان می‌رسد -- کامیت دوم جایگزین نتایج کامیت اول می‌شود.

[NOTE]
====
خیلی مهم است که بدانید که وقتی درحال امند کردن آخرین کامیت هستید، درواقع شما آن را با استفاده عمل _جایگزین‌_ تعمیر نمی‌کنید بلکه
یک ورودی جدید می‌سازید، کامیت بهبود یافته، کامیت قدیمی را کنار میزند و جایگزین آن می‌شود.
همانطور که انتظار داشتیم، انگار قبلا هیچ کامیت غلطی وجود نداشته و هیچ وقت در تاریخچهٔ مخزن شما نمایش داده نمی‌شود.

فایده مشخص امند کردن کامیت‌هااین است که بدون ایجاد درهم ریختگی در تاریخچه‌ٔ مخزن با پیغام کامیت‌های مثل
«اوه، اضافه کردن یک فایل فراموش شده بود‍‍» یا «اصلاح یک غلط املایی در کامیت آخر»، یک تغییر خیلی جزئی برای آخرین کامیت می‌سازید.
====

[[_unstaging]]
==== آن‌استیج کردن یک فایل استیج شده

دو قسمت بعدی درباره چگونگی کار با بخش استیج و تغیرات پوشه کاری توضیح می‌دهد.
قسمت قشنگ آن این است که دستوری که برای تعیین وضعیت آن دو بخش به کار می‌رود همچنین یاد‌آوری می‌کند که چگونه
تغییرات به عقب برگردانید.
برای مثال، بیایید بگوییم شما دو فایل را تغییر داده بودید و مخوایید آن‌ها را جدا از هم کامیت کنید، اما به اتفاقاً دستور
`git add *` را وارد می‌کنید و هر دو آن‌ها استیج می‌شوند.
چطور می‌توانید آن‌ها آن‌استیج کنید؟
دستور `git status` به شما یادآوری می‌کند.

[source,console]
----
$ git add *
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    renamed:    README.md -> README
    modified:   CONTRIBUTING.md
----

دقیقا بالای متن ``Changes to be comitted``، به شما گفته از `git reset HEAD <file> ...` برای آن‌استیج استفاده کنید.
پس بایید به توصیه گیت گوش کنیم و فایل `CONTRIBURING.md` را آن‌استیج کنیم:

[source,console]
----
$ git reset HEAD CONTRIBUTING.md
Unstaged changes after reset:
M	CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    renamed:    README.md -> README

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
----

دستور مقداری عجیب به نظر می‌رسد،‌ اما کار می‌کند.
فایل `CONTRIBUTING.md` تغییر کرده است اما دوباره به حال آن‌استیج درآمده است.

[NOTE]
=====
این درست که دستور `git reset` می‌تواند خطرناک باشد، مخصوصا اگر از فلگ `hard--` استفاده کرده باشید.
با این حال، در این سناریو که بالا توضیح داده شد، فایل در پوشه کاری شما قرار دارد متأثر خطرات نمی‌شود، پس امن است.
=====

در حال حاضر این توضیحات جادویی تمام چیزی بود که شما لازم داشتید تا درباره دستور `git reset` بدانید.
بعد تر در بخش <<ch07-git-tools#_git_reset>> با جزئیات بیشتری وارد بحث `reset` می‌شویم که چه کاری می‌کند
و چطور می‌توان در آن استاد شد تا چیزهای واقعاً جالب‌تری انجام داد.


==== بازگشت اصلاحات به قبل

چه می‌شود اگر بفهمید دیگر نمی‌خواهید تغییر فایل `COUNTRIBUTING.md` حفظ کنید؟
چطور می‌شود تغییرات را به حالت قبل برگرداند -- بازگرداندن آن به همان شکل که در آخرین کامیت شما بود
(یا کلون شده بود، یا همانگونه که وارد پوشه کاری شما شده بود).
خوشبختانه، `git status` این را نیز به شما می‌گوید که چگونه آن را انجام دهید.
در خروجی آخرین مثال، بخش آن‌استیج چیزی شبیه به این بود:

[source,console]
----
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
----

این به شما به زیبایی و صراحت می‌گوید که تغییرات انجام شده را چگونه از بین ببریم.
بزارید کاری که گفته شده را انجام دهیم:

[source,console]
----
$ git checkout -- CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    renamed:    README.md -> README

----

شما می‌‌توانید ببینید که تغییرات به حالت اول بازگشتند.

[IMPORTANT]
=====
خیلی مهم است بدانید که دستور `git checkout -- <file>` دستور خطرناکی است.
هر تغییری که محلی باشد و کامیت نشده باشد از بین خواهد رفت -- گیت تغییرات فایل‌ها را با آخرین نسخه کامیت‌ شده باز می‌گرداند.
از این دستور تا زمانی که نمی‌دانید دقیقا واقعا می‌دانید که به آن تغییرات نیاز ندارید انجام ندهید.
=====

اگر مایل هستید تا تغییراتی که ایجاد کرده بودید را حفظ کنید اما در حال حاضر می‌خواید سر راهتان نباشند، شما باید از سراغ استش کردن و شاخه‌ها
در بخش <<ch03-git-branching#ch03-git-branching>> بروید؛ به طور کلی این‌ها بهترین راه‌ها هستند.

یادتان باشد، هرچیزی که در گیت _کامیت‌_ شده باشد می‌تواند تقریبا همیشه بازگردانی شود.
حتی کامیت‌هایی که بر روی شاخه‌هایی که حذف شده بودند وجود داشتند یا کامیت‌هایی که با فلگ `amend--` بازنویسی شده‌ بودند می‌توانند بازگردانی شوند.


( بخش <<ch10-git-internals#_data_recovery>> را برای بازگردانی اطلاعات ببینید ).

با این حال، هر چیزی که شما کامیت نکرده باشد و از دست دهید، انگار هیچ وقت آن‌ها را نساخته بودید.
